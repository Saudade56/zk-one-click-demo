<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>匿名なのに一人一回ボタン (ZK)</title>
  <style>
    body { font-family: system-ui, sans-serif; padding: 2rem; max-width: 720px; margin:auto; }
    h1 { font-size: 1.4rem; }
    button { font-size: 1rem; padding: .8rem 1.2rem; }
    .box { background: #f7f7f8; border:1px solid #ddd; border-radius:8px; padding:1rem; margin-top:1rem; }
    .muted { color:#666; font-size:.9rem; }
    pre { white-space: pre-wrap; word-break: break-word; font-size: .8rem; }
  </style>
</head>
<body>
  <h1>匿名なのに「一人一回」ボタン（ゼロ知識証明デモ）</h1>
  <p class="muted">
    ※ 名前・メールアドレスなどは一切送りません。<br>
    送信するデータは下の「送信内容」に全部表示されます。
  </p>
  <button id="btn">+1 する</button>
  <div id="result" class="box" aria-live="polite"></div>
  <details class="box" open>
    <summary>送信内容プレビュー（proof / root / epoch / signal / nullifier）</summary>
    <pre id="payload"></pre>
  </details>
  <script type="module">
    import { Identity } from "https://esm.sh/@semaphore-protocol/identity@4.14.0";
    import { Group } from "https://esm.sh/@semaphore-protocol/group@4.14.0";
    import { generateProof } from "https://esm.sh/@semaphore-protocol/proof@4.14.0";

    const API = "https://zk-one-click-api.vercel.app";

    const KEY = "zk-demo-secret";

    // DOMの読み込み完了を待つ
    document.addEventListener("DOMContentLoaded", async () => {
      // 1) ブラウザ専用の秘密IDを発行（localStorageに保存）
      let identity;
      const secret = localStorage.getItem(KEY);
      if (!secret) {
        identity = new Identity();
        localStorage.setItem(KEY, identity.toString());
      } else {
        // Identityを文字列から復元
        identity = new Identity(secret);
      }

      const btn = document.getElementById("btn");
      const result = document.getElementById("result");
      const payloadBox = document.getElementById("payload");

      if (!btn || !result || !payloadBox) {
        console.error("Required elements not found");
        return;
      }

      btn.onclick = async () => {
        try {
          result.textContent = "証明を生成しています…（1〜2秒かかることがあります）";
          btn.disabled = true;

          // epoch = 今日の日付（例: "2025-12-05"）
          const today = new Date().toISOString().slice(0, 10);
          const epoch = today;
          const signal = "like";

          // デモ用の root（本気でやるときはサーバから配る）
          const root = "0x123456789abcdef";

          console.log("Generating proof...", { root, epoch, signal });

          // 2) Groupを作成（デモ用の空のGroup）
          // Groupのコンストラクタを試行: まずはtreeDepthのみ
          let group;
          try {
            // 方法1: treeDepthのみ
            console.log("Trying Group(20)...");
            group = new Group(20);
            console.log("Group created, adding member...");
            group.addMember(identity.commitment);
            console.log("Member added successfully");
          } catch (e1) {
            console.error("Method 1 failed:", e1);
            try {
              // 方法2: オプションオブジェクト
              console.log("Trying Group({ treeDepth: 20 })...");
              group = new Group({ treeDepth: 20 });
              console.log("Group created, adding member...");
              group.addMember(identity.commitment);
              console.log("Member added successfully");
            } catch (e2) {
              console.error("Method 2 failed:", e2);
              try {
                // 方法3: メンバー配列と一緒に
                console.log("Trying Group(20, [identity.commitment])...");
                group = new Group(20, [identity.commitment]);
                console.log("Group created with member");
              } catch (e3) {
                console.error("Method 3 failed:", e3);
                // 方法4: 空の配列で初期化
                try {
                  console.log("Trying Group([])...");
                  group = new Group([]);
                  group.addMember(identity.commitment);
                  console.log("Group created with empty array");
                } catch (e4) {
                  console.error("All Group constructor methods failed:", e1, e2, e3, e4);
                  throw new Error(`Failed to create Group. Last error: ${e4.message || e4}`);
                }
              }
            }
          }

          // 3) ゼロ知識証明を生成
          // Semaphore Protocolのデモ用circuitファイルを使用
          const wasmFilePath = "https://www.trusted-setup-pse.org/semaphore/20/semaphore.wasm";
          const zkeyFilePath = "https://www.trusted-setup-pse.org/semaphore/20/semaphore.zkey";

          const snarkArtifacts = {
            wasmFilePath,
            zkeyFilePath
          };

          // message = signal, scope = epoch
          const message = signal;
          const scope = epoch;

          const { proof, publicSignals } = await generateProof(
            identity,
            group,
            message,
            scope,
            20, // merkleTreeDepth
            snarkArtifacts
          );

          console.log("Proof generated:", { proof, publicSignals });

          const nullifier = publicSignals.nullifierHash;

          // 3) サーバに送るJSON
          const body = { proof, root, epoch, signal, nullifier };
          payloadBox.textContent = JSON.stringify(body, null, 2);

          console.log("Sending request to API...", `${API}/api/verify/rln`);

          // 4) Vercel Functions に送信
          const resp = await fetch(`${API}/api/verify/rln`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body)
          });

          console.log("Response status:", resp.status);

          const res = await resp.json();
          console.log("Response data:", res);

          if (resp.ok && res.ok) {
            result.textContent = `OK! いまのカウント: ${res.count}`;
          } else {
            result.textContent = `失敗: ${res.reason || "unknown error"}`;
          }
        } catch (e) {
          console.error("Error details:", e);
          result.textContent = `エラーが発生しました: ${e.message || e}`;
          payloadBox.textContent = `エラー詳細:\n${e.stack || e}`;
        } finally {
          btn.disabled = false;
        }
      };
    });
  </script>
</body>
</html>

