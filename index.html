<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>匿名なのに一人一回ボタン (ZK)</title>
  <style>
    body { font-family: system-ui, sans-serif; padding: 2rem; max-width: 720px; margin:auto; }
    h1 { font-size: 1.4rem; }
    button { font-size: 1rem; padding: .8rem 1.2rem; }
    .box { background: #f7f7f8; border:1px solid #ddd; border-radius:8px; padding:1rem; margin-top:1rem; }
    .muted { color:#666; font-size:.9rem; }
    pre { white-space: pre-wrap; word-break: break-word; font-size: .8rem; }
  </style>
</head>
<body>
  <h1>匿名なのに「一人一回」ボタン（ゼロ知識証明デモ）</h1>
  <p class="muted">
    ※ 名前・メールアドレスなどは一切送りません。<br>
    送信するデータは下の「送信内容」に全部表示されます。
  </p>
  <button id="btn">一人一回ボタン</button>
  <div id="result" class="box" aria-live="polite"></div>
  <details class="box" open>
    <summary>送信内容プレビュー（proof / root / epoch / signal / nullifier）</summary>
    <pre id="payload"></pre>
  </details>
  <script type="module">
    import { Identity } from "https://esm.sh/@semaphore-protocol/identity@4.14.0";
    import { Group } from "https://esm.sh/@semaphore-protocol/group@4.14.0";
    import { generateProof } from "https://esm.sh/@semaphore-protocol/proof@4.14.0";

    const API = "https://zk-one-click-api.vercel.app";
    const KEY = "zk-demo-secret";

    document.addEventListener("DOMContentLoaded", () => {
      const btn = document.getElementById("btn");
      const result = document.getElementById("result");
      const payloadBox = document.getElementById("payload");

      // Identityの取得または作成
      const secret = localStorage.getItem(KEY);
      const identity = secret ? new Identity(secret) : (() => {
        const id = new Identity();
        localStorage.setItem(KEY, id.toString());
        return id;
      })();

      btn.onclick = async () => {
        try {
          result.textContent = "証明を生成しています…";
          btn.disabled = true;

          const epoch = new Date().toISOString().slice(0, 10);
          const signal = "like";

          const group = new Group();
          group.addMember(identity.commitment);
          const root = group.root.toString();

          const proofResult = await generateProof(identity, group, epoch, signal, 20);
          const proof = proofResult.proof || proofResult;
          const publicSignals = proofResult.publicSignals || proofResult;
          const nullifier = publicSignals?.nullifierHash || publicSignals?.nullifier || proof?.nullifier;

          if (!proof || !nullifier) {
            throw new Error("証明の生成に失敗しました");
          }

          const body = { proof, root, epoch, signal, nullifier };
          payloadBox.textContent = JSON.stringify(body, null, 2);

          const resp = await fetch(`${API}/api/verify/rln`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body)
          });

          const res = await resp.json();

          if (resp.ok && res.ok) {
            result.textContent = `✅ 押しました！現在のカウント: ${res.count}`;
          } else {
            result.textContent = `❌ ${res.reason || "エラーが発生しました"}`;
          }
        } catch (e) {
          result.textContent = `エラー: ${e.message}`;
          payloadBox.textContent = e.stack || e;
        } finally {
          btn.disabled = false;
        }
      };
    });
  </script>
</body>
</html>
