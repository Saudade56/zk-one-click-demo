<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Semaphore Protocol テスト</title>
  <style>
    body { font-family: system-ui, sans-serif; padding: 2rem; max-width: 1200px; margin:auto; }
    pre { background: #f5f5f5; padding: 1rem; border-radius: 4px; overflow-x: auto; }
    .test-section { margin: 2rem 0; padding: 1rem; border: 1px solid #ddd; border-radius: 8px; }
    button { padding: 0.5rem 1rem; margin: 0.5rem 0.5rem 0.5rem 0; }
  </style>
</head>
<body>
  <h1>Semaphore Protocol generateProof テスト</h1>
  <div id="results"></div>

  <script type="module">
    import { Identity } from "https://esm.sh/@semaphore-protocol/identity@4.14.0";
    import { Group } from "https://esm.sh/@semaphore-protocol/group@4.14.0";
    import { generateProof } from "https://esm.sh/@semaphore-protocol/proof@4.14.0";

    const resultsDiv = document.getElementById("results");

    function log(message, data = null) {
      const pre = document.createElement("pre");
      pre.textContent = message + (data ? "\n" + JSON.stringify(data, null, 2) : "");
      resultsDiv.appendChild(pre);
    }

    function createTestSection(title) {
      const section = document.createElement("div");
      section.className = "test-section";
      const h2 = document.createElement("h2");
      h2.textContent = title;
      section.appendChild(h2);
      resultsDiv.appendChild(section);
      return section;
    }

    async function test1() {
      const section = createTestSection("テスト1: 基本的なgenerateProof呼び出し（URL文字列）");
      try {
        const identity = new Identity();
        const group = new Group();
        group.addMember(identity.commitment);

        log("Identity作成成功");
        log("Group作成成功", { root: group.root.toString() });

        const message = "test";
        const scope = "2025-01-01";

        // テスト1: URL文字列を直接渡す
        log("snarkArtifactsとしてURL文字列を渡す...");
        const { proof, publicSignals } = await generateProof(
          identity,
          group,
          scope,
          message,
          20,
          "https://www.trusted-setup-pse.org/semaphore/20"
        );

        log("✅ 成功！", { proof, publicSignals });
      } catch (e) {
        log("❌ エラー: " + e.message);
        log("スタックトレース:", e.stack);
      }
    }

    async function test2() {
      const section = createTestSection("テスト2: snarkArtifactsオブジェクト（wasmFilePath/zkeyFilePath）");
      try {
        const identity = new Identity();
        const group = new Group();
        group.addMember(identity.commitment);

        const message = "test";
        const scope = "2025-01-01";

        // テスト2: オブジェクト形式
        log("snarkArtifactsとしてオブジェクトを渡す...");
        const snarkArtifacts = {
          wasmFilePath: "https://www.trusted-setup-pse.org/semaphore/20/semaphore.wasm",
          zkeyFilePath: "https://www.trusted-setup-pse.org/semaphore/20/semaphore.zkey"
        };

        const { proof, publicSignals } = await generateProof(
          identity,
          group,
          scope,
          message,
          20,
          snarkArtifacts
        );

        log("✅ 成功！", { proof, publicSignals });
      } catch (e) {
        log("❌ エラー: " + e.message);
        log("スタックトレース:", e.stack);
      }
    }

    async function test3() {
      const section = createTestSection("テスト3: パラメータ順序の確認（identity, group, message, scope, treeDepth, snarkArtifacts）");
      try {
        const identity = new Identity();
        const group = new Group();
        group.addMember(identity.commitment);

        const message = "test";
        const scope = "2025-01-01";

        // テスト3: パラメータ順序を変更
        log("パラメータ順序を変更して試す...");
        const { proof, publicSignals } = await generateProof(
          identity,
          group,
          message, // signalを先に
          scope,   // externalNullifierを後に
          20,
          "https://www.trusted-setup-pse.org/semaphore/20"
        );

        log("✅ 成功！", { proof, publicSignals });
      } catch (e) {
        log("❌ エラー: " + e.message);
        log("スタックトレース:", e.stack);
      }
    }

    async function test5() {
      const section = createTestSection("テスト5: snarkArtifactsなしで試す（デフォルトのcircuitを使用）");
      try {
        const identity = new Identity();
        const group = new Group();
        group.addMember(identity.commitment);

        const message = "test";
        const scope = "2025-01-01";

        // テスト5: snarkArtifactsなし
        log("snarkArtifactsなしで試す...");
        const result = await generateProof(
          identity,
          group,
          scope,
          message,
          20
        );

        log("✅ 成功！");
        log("戻り値の型:", typeof result);
        log("戻り値のキー:", Object.keys(result || {}));
        log("戻り値全体:", result);
        log("proof:", result?.proof);
        log("publicSignals:", result?.publicSignals);
        log("nullifierHash:", result?.publicSignals?.nullifierHash || result?.nullifierHash);
      } catch (e) {
        log("❌ エラー: " + e.message);
        log("スタックトレース:", e.stack);
      }
    }

    async function test6() {
      const section = createTestSection("テスト6: 実際のコードと同じ形式で試す");
      try {
        const identity = new Identity();
        const group = new Group();
        group.addMember(identity.commitment);

        const root = group.root.toString();
        const epoch = new Date().toISOString().slice(0, 10);
        const signal = "like";

        log("実際のコードと同じ形式で試す...", { root, epoch, signal });

        const snarkArtifacts = {
          wasmFilePath: "https://www.trusted-setup-pse.org/semaphore/20/semaphore.wasm",
          zkeyFilePath: "https://www.trusted-setup-pse.org/semaphore/20/semaphore.zkey"
        };

        const { proof, publicSignals } = await generateProof(
          identity,
          group,
          epoch, // externalNullifier
          signal, // signal
          20, // merkleTreeDepth
          snarkArtifacts
        );

        log("✅ 成功！", { 
          proof: Object.keys(proof), 
          publicSignals: Object.keys(publicSignals),
          nullifier: publicSignals.nullifierHash 
        });
      } catch (e) {
        log("❌ エラー: " + e.message);
        log("スタックトレース:", e.stack);
        log("エラー詳細:", e);
      }
    }

    async function test7() {
      const section = createTestSection("テスト7: snarkArtifactsをwasm/zkey形式で試す");
      try {
        const identity = new Identity();
        const group = new Group();
        group.addMember(identity.commitment);

        const epoch = new Date().toISOString().slice(0, 10);
        const signal = "like";

        log("wasm/zkey形式で試す...");

        // URLからファイルを読み込む
        const wasmResponse = await fetch("https://www.trusted-setup-pse.org/semaphore/20/semaphore.wasm");
        const wasm = await wasmResponse.arrayBuffer();
        const zkeyResponse = await fetch("https://www.trusted-setup-pse.org/semaphore/20/semaphore.zkey");
        const zkey = await zkeyResponse.arrayBuffer();

        const snarkArtifacts = {
          wasm: wasm,
          zkey: zkey
        };

        const { proof, publicSignals } = await generateProof(
          identity,
          group,
          epoch,
          signal,
          20,
          snarkArtifacts
        );

        log("✅ 成功！", { 
          proof: Object.keys(proof), 
          publicSignals: Object.keys(publicSignals),
          nullifier: publicSignals.nullifierHash 
        });
      } catch (e) {
        log("❌ エラー: " + e.message);
        log("スタックトレース:", e.stack);
      }
    }

    async function test4() {
      const section = createTestSection("テスト4: generateProof関数のシグネチャを確認");
      try {
        log("generateProof関数の情報を確認...");
        log("generateProof関数:", generateProof.toString().substring(0, 500));
        log("generateProof.length (引数の数):", generateProof.length);
      } catch (e) {
        log("❌ エラー: " + e.message);
      }
    }

    // テスト実行
    document.addEventListener("DOMContentLoaded", async () => {
      log("テスト開始...\n");

      await test4(); // まず関数の情報を確認
      await test1();
      await test2();
      await test3();
      await test5();
      await test6(); // 実際のコードと同じ形式
      await test7(); // wasm/zkey形式
    });
  </script>
</body>
</html>

